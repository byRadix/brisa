# Reglas de Desarrollo para Brisa.app - Plataforma de Marketplace para Freelancers

## ğŸ¯ Objetivo del Proyecto
Brisa.app es una plataforma de marketplace para freelancers que conecta profesionales con clientes. El proyecto debe desarrollarse con una arquitectura escalable, mantenible y siguiendo las mejores prÃ¡cticas de desarrollo moderno.

## ğŸ—ï¸ Arquitectura y Estructura

### Principios ArquitectÃ³nicos
- **Arquitectura SPA (Single Page Application)** con React 18 + TypeScript
- **Backend-as-a-Service** con Supabase (PostgreSQL + Auth + Storage)
- **SeparaciÃ³n de responsabilidades** clara entre componentes, servicios y lÃ³gica de negocio
- **DiseÃ±o responsivo** con Tailwind CSS
- **Estado global** manejado con React Context API

### Estructura de Directorios
```
src/
â”œâ”€â”€ components/          # Componentes reutilizables organizados por dominio
â”‚   â”œâ”€â”€ ui/             # Componentes UI bÃ¡sicos (Button, Input, etc.)
â”‚   â”œâ”€â”€ layouts/        # Layouts principales (MainLayout, DashboardLayout)
â”‚   â”œâ”€â”€ marketplace/    # Componentes especÃ­ficos del marketplace
â”‚   â”œâ”€â”€ auth/           # Componentes de autenticaciÃ³n
â”‚   â””â”€â”€ [domain]/       # Otros dominios especÃ­ficos
â”œâ”€â”€ pages/              # PÃ¡ginas principales (una por archivo)
â”œâ”€â”€ contexts/           # Context providers para estado global
â”œâ”€â”€ services/           # Servicios para APIs y lÃ³gica de negocio
â”œâ”€â”€ lib/                # Utilidades, configuraciones y tipos
â”œâ”€â”€ types/              # Definiciones de tipos TypeScript
â””â”€â”€ data/               # Datos de ejemplo y mocks
```

## ğŸ“ EstÃ¡ndares de CÃ³digo

### TypeScript
- **Usar TypeScript estrictamente** - no usar `any` sin justificaciÃ³n
- **Definir interfaces/tipos** para todas las props de componentes
- **Usar tipos genÃ©ricos** cuando sea apropiado
- **Exportar tipos** desde archivos dedicados en `/types`
- **Usar enums** para valores constantes (estados, categorÃ­as, etc.)

### React y Componentes
- **Usar Functional Components** con hooks
- **Props tipadas** con interfaces TypeScript
- **Componentes pequeÃ±os y enfocados** - mÃ¡ximo 200 lÃ­neas por componente
- **Usar React.memo()** para componentes que se re-renderizan frecuentemente
- **Implementar error boundaries** para manejo de errores
- **Usar lazy loading** para componentes pesados

### Nomenclatura
- **Componentes**: PascalCase (ej: `UserProfile.tsx`)
- **Archivos**: PascalCase para componentes, camelCase para utilidades
- **Variables/funciones**: camelCase
- **Constantes**: UPPER_SNAKE_CASE
- **Interfaces**: PascalCase con prefijo I (ej: `IUserProfile`)
- **Tipos**: PascalCase (ej: `UserStatus`)

### Estructura de Componentes
```typescript
// 1. Imports
import React from 'react';
import { ComponentProps } from './types';

// 2. Interfaces/Tipos
interface IComponentProps {
  // props aquÃ­
}

// 3. Componente
export const Component: React.FC<IComponentProps> = ({ prop1, prop2 }) => {
  // 4. Hooks
  const [state, setState] = useState();
  
  // 5. Handlers
  const handleClick = () => {
    // lÃ³gica
  };
  
  // 6. Render
  return (
    <div>
      {/* JSX */}
    </div>
  );
};
```

## ğŸ¨ Estilos y UI

### Tailwind CSS
- **Usar clases de Tailwind** en lugar de CSS personalizado
- **Crear componentes UI reutilizables** en `/components/ui`
- **Usar variables CSS** para colores y espaciados consistentes
- **Implementar diseÃ±o responsivo** con breakpoints de Tailwind
- **Usar dark mode** cuando sea apropiado

### DiseÃ±o Responsivo
- **Mobile-first approach** - diseÃ±ar primero para mÃ³vil
- **Breakpoints estÃ¡ndar**: sm (640px), md (768px), lg (1024px), xl (1280px)
- **Usar flexbox/grid** para layouts complejos
- **Optimizar imÃ¡genes** para diferentes tamaÃ±os de pantalla

## ğŸ” Seguridad y AutenticaciÃ³n

### Supabase Auth
- **Usar Row Level Security (RLS)** en todas las tablas
- **Validar permisos** en el frontend y backend
- **Implementar refresh tokens** correctamente
- **Sanitizar inputs** antes de enviar a la base de datos
- **Usar variables de entorno** para configuraciones sensibles

### ValidaciÃ³n de Datos
- **Validar en frontend** con bibliotecas como Zod o Yup
- **Validar en backend** con RLS policies
- **Sanitizar HTML** para prevenir XSS
- **Implementar rate limiting** para APIs

## ğŸ—„ï¸ Base de Datos y Supabase

### Estructura de Tablas
- **Usar UUIDs** como claves primarias
- **Implementar timestamps** (created_at, updated_at) en todas las tablas
- **Usar foreign keys** para relaciones
- **Indexar campos** frecuentemente consultados
- **Usar RLS policies** para seguridad

### Migraciones
- **Crear migraciones incrementales** en `/supabase/migrations`
- **Documentar cambios** en las migraciones
- **Probar migraciones** en entorno de desarrollo
- **Usar nombres descriptivos** para las migraciones

### Queries
- **Optimizar queries** con Ã­ndices apropiados
- **Usar joins** en lugar de mÃºltiples queries
- **Implementar paginaciÃ³n** para listas grandes
- **Usar prepared statements** para prevenir SQL injection

## ğŸš€ Performance y OptimizaciÃ³n

### Rendimiento Frontend
- **Lazy loading** de componentes y rutas
- **Code splitting** por rutas
- **Optimizar imÃ¡genes** con formatos modernos (WebP, AVIF)
- **Usar React.memo()** para evitar re-renders innecesarios
- **Implementar virtualizaciÃ³n** para listas largas

### OptimizaciÃ³n de Bundle
- **Tree shaking** para eliminar cÃ³digo no usado
- **Minificar** CSS y JavaScript
- **Comprimir** assets estÃ¡ticos
- **Usar CDN** para assets externos

### Caching
- **Implementar caching** en el cliente con React Query o SWR
- **Usar localStorage** para datos no sensibles
- **Cachear queries** de Supabase apropiadamente

## ğŸ“± UX/UI y Accesibilidad

### Accesibilidad (a11y)
- **Usar semantic HTML** (nav, main, section, etc.)
- **Implementar ARIA labels** y roles
- **Soporte para navegaciÃ³n por teclado**
- **Contraste de colores** adecuado (WCAG 2.1)
- **Alt text** para imÃ¡genes

### Experiencia de Usuario
- **Loading states** para operaciones asÃ­ncronas
- **Error handling** con mensajes claros
- **Feedback visual** para acciones del usuario
- **Formularios intuitivos** con validaciÃ³n en tiempo real
- **Responsive design** en todos los dispositivos

## ğŸ§ª Testing y Calidad

### Testing
- **Unit tests** para utilidades y hooks
- **Component tests** para componentes crÃ­ticos
- **Integration tests** para flujos principales
- **E2E tests** para user journeys crÃ­ticos

### Linting y Formateo
- **ESLint** para detectar errores y mantener consistencia
- **Prettier** para formateo de cÃ³digo
- **Husky** para pre-commit hooks
- **TypeScript strict mode** habilitado

## ğŸ“¦ GestiÃ³n de Dependencias

### Dependencias
- **Mantener dependencias actualizadas** regularmente
- **Usar versiones especÃ­ficas** en package.json
- **Auditar dependencias** regularmente
- **Preferir dependencias mantenidas** y populares

### ConfiguraciÃ³n
- **Usar Vite** como bundler principal
- **Configurar alias** para imports mÃ¡s limpios
- **Optimizar build** para producciÃ³n
- **Usar environment variables** apropiadamente

## ğŸ”„ Estado y GestiÃ³n de Datos

### Context API
- **Usar Context API** para estado global
- **Separar contextos** por dominio (Auth, Notifications, etc.)
- **Optimizar re-renders** con useMemo y useCallback
- **Documentar** la estructura del estado

### Servicios
- **Crear servicios** para lÃ³gica de negocio
- **Separar concerns** entre UI y lÃ³gica
- **Usar TypeScript** para APIs
- **Implementar error handling** consistente

## ğŸ“ˆ Escalabilidad

### Arquitectura Escalable
- **Modular design** para facilitar expansiÃ³n
- **Micro-frontends** consideraciÃ³n futura
- **API versioning** para cambios breaking
- **Database sharding** preparaciÃ³n

### Performance
- **CDN** para assets estÃ¡ticos
- **Database indexing** estratÃ©gico
- **Caching layers** (Redis, etc.)
- **Load balancing** preparaciÃ³n

## ğŸš¨ Manejo de Errores

### Frontend
- **Error boundaries** para capturar errores de React
- **Try-catch** para operaciones asÃ­ncronas
- **Logging** de errores para debugging
- **User-friendly** mensajes de error

### Backend
- **RLS policies** para validaciÃ³n
- **Database constraints** para integridad
- **API error responses** consistentes
- **Monitoring** y alerting

## ğŸ“š DocumentaciÃ³n

### CÃ³digo
- **JSDoc** para funciones complejas
- **README** actualizado para cada componente
- **Storybook** para componentes UI
- **API documentation** con ejemplos

### Proyecto
- **README.md** con setup instructions
- **CHANGELOG.md** para versiones
- **CONTRIBUTING.md** para contribuidores
- **Architecture decisions** documentadas

## ğŸ”§ ConfiguraciÃ³n de Desarrollo

### Entorno Local
- **Node.js 18+** requerido
- **npm/yarn** para gestiÃ³n de dependencias
- **Git** para control de versiones
- **VS Code** con extensiones recomendadas

### Variables de Entorno
```env
# Supabase
VITE_SUPABASE_URL=
VITE_SUPABASE_ANON_KEY=

# External APIs
VITE_EXTERNAL_API_URL=
VITE_EXTERNAL_API_KEY=

# Feature Flags
VITE_ENABLE_FEATURE_X=true
```

## ğŸ¯ Metas de Desarrollo

### Corto Plazo
- [ ] Implementar sistema de autenticaciÃ³n completo
- [ ] Crear marketplace funcional
- [ ] Sistema de valoraciones y reseÃ±as
- [ ] Dashboard de usuario

### Mediano Plazo
- [ ] Sistema de mensajerÃ­a en tiempo real
- [ ] Notificaciones push
- [ ] Sistema de pagos integrado
- [ ] Analytics y mÃ©tricas

### Largo Plazo
- [ ] AplicaciÃ³n mÃ³vil nativa
- [ ] API pÃºblica para desarrolladores
- [ ] IntegraciÃ³n con herramientas de freelancers
- [ ] Marketplace internacional

## âš ï¸ Anti-patrones a Evitar

- âŒ **No usar `any`** en TypeScript
- âŒ **No crear componentes monolÃ­ticos** (mÃ¡s de 200 lÃ­neas)
- âŒ **No hardcodear** valores sensibles
- âŒ **No ignorar** errores de linting
- âŒ **No usar** inline styles cuando se puede usar Tailwind
- âŒ **No crear** dependencias circulares
- âŒ **No usar** `console.log` en producciÃ³n
- âŒ **No implementar** lÃ³gica de negocio en componentes

## ğŸ‰ ConclusiÃ³n

Este proyecto debe desarrollarse pensando en la escalabilidad y mantenibilidad a largo plazo. Cada decisiÃ³n tÃ©cnica debe considerar el impacto en el rendimiento, la experiencia del usuario y la capacidad de crecimiento de la plataforma.

**Recuerda**: La calidad del cÃ³digo es tan importante como la funcionalidad. Un cÃ³digo bien estructurado y documentado facilitarÃ¡ el mantenimiento y la expansiÃ³n futura de Brisa.app. 